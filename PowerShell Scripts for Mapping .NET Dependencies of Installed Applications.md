# PowerShell Scripts for Mapping .NET Dependencies of Installed Applications

#### Quick Summary
>
> - No Built-in Tool – Community to the Rescue
> Microsoft has no native utility to list which installed apps depend on which .NET version. Sysadmins have filled the gap with PowerShell scripts that scan installed programs and identify their .NET Framework or .NET runtime requirements.
> 
> - File Scanning to Detect Dependencies
> Scripts typically work by scanning program installation folders for tell-tale .NET assembly files (e.g. `System*.dll`, `mscorlib.dll`) or manifest entries. By retrieving file version info of these assemblies, the script infers the .NET version required.
> 
> - Structured Output for Enterprise Use
> These scripts output results in a structured format (CSV or JSON), mapping each software to the .NET version it needs. This data can be aggregated across thousands of endpoints and analyzed centrally – essential for a large enterprise environment.
> 
> - Deployable via SCCM, Intune, Tanium
> You can run the script on all PCs using your management tools (ConfigMgr/SCCM, Intune, or platforms like Tanium) and collect the results automatically. No new agent is required – leverage existing infrastructure to execute the script on each machine and retrieve the inventory data.


## **Background:** Why a Script is Needed

Identifying which installed applications rely on which version of the .NET Framework (or .NET Core/5/6/7 runtimes) is a non-trivial task. Unlike simply listing what versions of .NET are installed on a system, determining **“which apps need which .NET versions”** requires analyzing the applications themselves. As of 2022, an admin in a Microsoft Q\&A forum asked if any tool or script could do this, and the consensus was grim: **there was no official or straightforward method**[1](https://learn.microsoft.com/en-us/answers/questions/791530/determining-net-dependency). Microsoft representatives confirmed that *“there seems to be no way to check all the app’s .NET version dependencies simply by code or tooling”*[1](https://learn.microsoft.com/en-us/answers/questions/791530/determining-net-dependency). In practice, admins were left to either **uninstall old .NET versions and see what breaks** (a risky trial-and-error approach[1](https://learn.microsoft.com/en-us/answers/questions/791530/determining-net-dependency)), or attempt a manual analysis of each program.

This gap spurred community solutions. In early 2022, IT professionals discussed possible approaches on forums. One idea was to literally scan through every executable on a PC for a specific marker string indicating a .NET dependency. In a Spiceworks thread, an admin noted that *“Looks like I’m going to have to search through every EXE file on a machine & look for the ‘NETFramework,Version’ string!”* as a last resort[2](https://community.spiceworks.com/t/is-there-a-tool-to-determine-which-applications-are-using-which-versions-of-net/826293). This string (e.g. `".NETFramework,Version=v4.7.2"`) often appears in the metadata of a .NET assembly and can hint at the target framework. Indeed, others have observed that *“looking for the NETFramework,Version string inside an .exe gives you a pretty accurate ballpark”* of what .NET version it targets[3](https://stackoverflow.com/questions/3172751/how-do-i-check-the-net-version-of-an-app). However, manually scanning binary files across many machines is cumbersome and potentially unreliable without automation.

Fast-forward to mid-2024: seeing this challenge, community experts created **PowerShell scripts to automate the dependency discovery**. These scripts are designed to run on Windows machines, inspect installed software, and produce a report of which apps require which .NET versions. They aim to be scalable (so they can be executed on hundreds or thousands of PCs remotely) and to output data in a structured way (CSV, JSON) that can be aggregated.

**In summary**, there’s no one-click Microsoft tool for this job, but PowerShell provides the means to build one. Below we’ll explore how these scripts work, highlight a notable example, discuss their output and limitations, and cover strategies for deploying them across an enterprise.


## **How the Scripts Work:** Scanning Installed Programs for .NET Clues

Most scripts tackling this problem follow a similar high-level approach:

1.  **Enumerate Installed Applications** – First, gather the list of installed programs on the system. This is typically done by querying the registry uninstall keys (both 64-bit and 32-bit) for programs, similar to what `Get-WmiObject Win32_Product` or manual registry reads would yield. PowerShell can read those registry paths (HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall and the WOW6432Node equivalent) to get DisplayName, version, and importantly the **InstallLocation** path of each app[4](https://quynnbell.com/identify-net-and-visual-c-dependencies-using-powershell/). This gives us each application’s installation directory on disk.

2.  **Probe Each Application’s Files for .NET Dependencies** – For each installed application (each InstallLocation), the script looks at the files present (typically .exe and .dll files) to detect any that indicate a .NET dependency. There are a few techniques to do this:
    *   **Search for Known .NET Assemblies:** This is the method used by one popular script (discussed below). The script defines a set of filename patterns that are characteristic of .NET runtime components, for example:

        *   `System*.dll` – Many core .NET assemblies begin with “System.” (System.Core.dll, System.Windows.Forms.dll, etc.).
        *   `mscorlib.dll` – The mscorlib (Microsoft Core Library) is a fundamental .NET assembly present in .NET Framework apps.

        The presence of these files in an application’s folder often means the app is built on .NET and includes some .NET libraries. The script scans the app’s directory (and subfolders) for any files matching those patterns[4](https://quynnbell.com/identify-net-and-visual-c-dependencies-using-powershell/). If found, it then uses the **System.Diagnostics.FileVersionInfo** class to get the file’s version information[4](https://quynnbell.com/identify-net-and-visual-c-dependencies-using-powershell/). For .NET assemblies, the “Product Version” or “File Version” typically corresponds to the .NET version. For instance, if it finds a `mscorlib.dll` with product version 4.8.4084, that indicates .NET Framework 4.8; if it finds `System.Private.CoreLib.dll` version 6.0.0, that indicates .NET 6, etc.

        This method is effective because the version of core assemblies directly maps to the runtime version. The script then records that application X has a dependency on .NET version Y.

    *   **Check for Manifest or Config Files:** Some applications include a manifest file (`YourApp.exe.manifest`) or a config file that explicitly states the required .NET version. For example, a manifest might contain a dependency entry for *Microsoft.Windows.Common-Controls* and sometimes for .NET. A PowerShell script can look for a manifest and search it for a string like `Microsoft .NETFramework` or a `supportedRuntime` entry. One proposed script (pseudo-code generated on CodePal) shows reading an app’s manifest and looking for the text `"Microsoft.NETFramework"` as an indicator[5](https://codepal.ai/code-generator/query/AbPgUfYl/powershell-function-check-application-dependency)[5](https://codepal.ai/code-generator/query/AbPgUfYl/powershell-function-check-application-dependency). If found, that app is flagged as needing .NET. This approach can tell you if .NET is needed, but parsing the exact version might require reading the specific version string from the manifest content.

    *   **Binary Metadata Inspection:** A more advanced approach is to inspect the executable file’s metadata directly. .NET executables (and DLLs) carry metadata that includes the CLR version. A PowerShell script can attempt to load the assembly metadata. For example, using `[Reflection.AssemblyName]::GetAssemblyName("path\to\app.exe")` inside a try/catch. If the file is a .NET assembly, this will succeed and the returned AssemblyName may include references that hint at the framework (like referencing mscorlib v2.0 vs v4.0, etc.). As one Stack Overflow user noted, tools like .NET Reflector or ILSpy can reveal an assembly’s target framework, so in principle a script could do the same by inspecting the assembly’s manifest and references[3](https://stackoverflow.com/questions/3172751/how-do-i-check-the-net-version-of-an-app). This method can directly tell if an EXE is a .NET assembly and even retrieve the *TargetFrameworkAttribute* (which might say “.NETFramework,Version=v4.6.1” for instance).

    *   **String Search in Binaries:** As mentioned, a simpler but brute-force technique is searching the binary file for known strings. Many .NET assemblies include the target framework moniker as a human-readable string. For example, if you open a .NET EXE in Notepad and search for “.NETFramework”, you might find a snippet like `<TargetFramework>.NETFramework,Version=v4.7.2</TargetFramework>` embedded. A PowerShell script could scan the bytes of the EXE for the pattern `"NETFramework,Version=v"` and read the next few characters to capture the version. This was suggested in forum discussions as a last resort[2](https://community.spiceworks.com/t/is-there-a-tool-to-determine-which-applications-are-using-which-versions-of-net/826293)[3](https://stackoverflow.com/questions/3172751/how-do-i-check-the-net-version-of-an-app). It’s a bit hacky, but can work for frameworks; for .NET Core apps, the string might be “.NETCoreApp,Version=v3.1” etc., which one could also search for.

3.  **Capture Dependency Versions** – However the script finds evidence of .NET usage, it then determines *which* version. In the file-based approach, this is done by capturing the version of the DLL as mentioned. In other approaches, it might be by capturing the string or assembly reference. The output typically records the **highest .NET version** used by the app (or potentially multiple if an app has different components, though most have one primary target).

4.  **Output the Results** – Finally, the script outputs a consolidated list of programs and their .NET dependencies. PowerShell makes it easy to collect data in an array of objects and then output to formats like CSV or JSON. Most scripts choose CSV for simplicity. For example, one script writes the output to `C:\ProgramDependencies.csv` on each machine[4](https://quynnbell.com/identify-net-and-visual-c-dependencies-using-powershell/). Each row in the CSV might contain columns like *Program Name*, *Version*, *DependencyType*, *DependencyVersion*[4](https://quynnbell.com/identify-net-and-visual-c-dependencies-using-powershell/). (DependencyType could be “DotNet” vs “VisualCpp” if it also checks C++ redists – more on that below.)

### **Example: Quynn Bell’s .NET Dependency Scanner Script**

A standout example is the PowerShell script published by Quynn Bell in May 2024, titled *“.NET and Visual C++ Determiner”*. Quynn developed it exactly to solve the problem of identifying which apps rely on old .NET or Visual C++ runtimes[4](https://quynnbell.com/identify-net-and-visual-c-dependencies-using-powershell/)[4](https://quynnbell.com/identify-net-and-visual-c-dependencies-using-powershell/). Here’s how Quynn’s script operates:

*   It retrieves all installed programs from registry (both 64-bit and 32-bit uninstall keys) into a list (`Get-InstalledPrograms` function)[4](https://quynnbell.com/identify-net-and-visual-c-dependencies-using-powershell/).
*   It defines two arrays of filename patterns: one for .NET indicators and one for Visual C++ indicators. The .NET patterns are `@"System.*.dll", "mscorlib.dll"`[4](https://quynnbell.com/identify-net-and-visual-c-dependencies-using-powershell/). The Visual C++ patterns include common VC runtime DLL names like `msvcp*.dll`, `vcruntime*.dll`, etc.[4](https://quynnbell.com/identify-net-and-visual-c-dependencies-using-powershell/).
*   For each installed program, if an *InstallLocation* is available (meaning the app has a folder on disk), the script scans that folder and subfolders for any files matching the .NET patterns[4](https://quynnbell.com/identify-net-and-visual-c-dependencies-using-powershell/). It uses `Get-ChildItem -Recurse` to find these files.
*   When a matching file is found (say `C:\Program Files\Contoso\App\mscorlib.dll`), it calls the function `Get-DotNetVersion` which uses `[System.Diagnostics.FileVersionInfo]::GetVersionInfo(<file>)` to get the product version of the DLL. For example, if `mscorlib.dll` has ProductVersion `4.7.3062.0`, the script captures that.
*   It creates a PowerShell object with properties: Program (name), Version (program version), Dependency (file name, e.g. mscorlib.dll), DependencyType (“DotNet”), and DependencyVersion (e.g. 4.7.3062.0). This object is added to a collection.
*   It does the same for the Visual C++ pattern matches (DependencyType “VisualCpp”, using the same FileVersionInfo to get the DLL version).
*   After scanning all programs, the script outputs the collected objects in a formatted table on the console, and also **exports to CSV** at `C:\ProgramDependencies.csv`.

Quynn’s script effectively correlates each installed application with the specific runtime libraries it depends on. The resulting CSV can be opened in Excel or processed further. The author notes that this makes it easy to identify which software requires which versions of .NET or VC++, *“ensuring we don’t accidentally remove a critical dependency and cause unforeseen issues”*. In other words, before uninstalling an older .NET version from a machine, you can check if any app on that machine needed it.

**Output format:** The CSV contains one line per dependency found. If an app has multiple dependencies (say it uses .NET and also an old VC++ runtime), it will have multiple lines. For .NET, typically one representative DLL is enough to identify the version. Here’s a simplified example illustrating what the output might look like (for .NET only):

| **Device** | **Application**       | **App Version** | **.NET Dependency**        | **.NET Version (Product)** |
| ---------- | --------------------- | --------------- | -------------------------- | -------------------------- |
| PC001      | Contoso CRM Client    | 5.4.0           | mscorlib.dll               | 4.8.9075.0                 |
| PC001      | LegacyTool Pro        | 2.1             | mscorlib.dll               | 2.0.50727.4927             |
| PC002      | Fabrikam Analysis App | 3.0.1           | System.Private.CoreLib.dll | 6.0.13                     |
| PC002      | Fabrikam Analysis App | 3.0.1           | System.Windows.Forms.dll   | 6.0.13                     |
| PC002      | Internal Utility X    | 1.0             | *\<no .NET found>*         | *N/A*                      |

*(In the above hypothetical snippet, PC001 has two apps: one needing .NET 4.8, another needing the old .NET 2.0/3.5 CLR; PC002 has an app built on .NET 6.0 – indicated by core library version – and another app that is not a .NET app at all.)*

Quynn’s actual script lists each dependency file, which is why Fabrikam app appears twice (it found two different System assemblies, both of which are part of .NET 6). In analysis, one usually generalizes: if any .NET 6 assembly was found, the app uses .NET 6. It’s straightforward to pivot the data by app to get a unique list of required runtimes.

**Reliability:** This script is quite reliable for conventional installed software. It will catch most .NET Framework applications because they typically either install some .NET assemblies alongside or at least have `mscorlib.dll` if they include certain libraries (some pure .NET apps might not ship mscorlib if they rely wholly on the system’s copy, but many include some System.\* assemblies for plugins or UI). It will definitely catch self-contained .NET Core apps (which bundle their runtime libraries, so dozens of System.\* DLLs will be in the folder). If an app is a framework-dependent .NET Core app (meaning it requires the runtime installed but doesn’t carry those DLLs), the script might miss it because there’s no System.\* file in the app folder. Those cases are rarer in desktop apps but possible; a fallback could be to search the main .exe for the target framework string.

**Other scripts and variations:** Aside from Quynn’s script, administrators have crafted variations:

*   A script could include searching the application’s main EXE as well as DLLs. For example, one might add `"*.exe"` to the search patterns and filter those that are managed. But distinguishing a managed EXE from a native one can be done by trying to get FileVersionInfo (though even native EXEs have versions) or loading it via reflection in a try/catch.
*   As demonstrated on the CodePal example, a script might specifically look for `.exe.manifest` files and parse them for a `<dependency>` on Microsoft.NETFramework.
*   A purely string-based script could brute force scan, but it’s less structured.

The consensus in the sysadmin community is that **PowerShell is the tool of choice** because it can gracefully handle the registry queries, file system scanning, and even assembly inspection if needed, all in one script. And importantly, it can output the data in a machine-readable format (CSV/JSON) which is critical for analysis.

## **Limitations and Considerations**

No approach is 100% foolproof. When using or developing such scripts, keep in mind:

*   **Not all .NET apps leave obvious traces in the file system:** A .NET Framework app that relies entirely on the globally installed runtime might not include any `System.*` DLLs in its installer. Quynn’s script would not list a dependency for it because it finds none of the target files. In such a case, the app *does* depend on .NET (the one installed in Windows), but the script would output nothing for that app. One way to catch these would be the “string search” method on the EXE itself. If you suspect such apps, you might augment the script to search each EXE for “NETFramework,Version”. This would add some overhead, but could reveal, for example, that *MyApp.exe* contains “…`.NETFramework,Version=v4.6.1`…” inside, indicating it targets 4.6.1. This string-search method was acknowledged as likely necessary in the Spiceworks discussion. In practice, you might not need to scan *every* EXE on the system, just those for which the initial method found nothing but that you suspect might be .NET apps (perhaps by name or publisher). Combining both approaches yields a more complete result.

*   **Mapping .NET Core / .NET 5+ runtimes:** .NET Core and later allow *self-contained* deployments. If an app is published as self-contained, it will carry its own private copy of the .NET runtime. In those cases, the script *will* find System.Private.CoreLib.dll etc., and correctly identify the version (which corresponds to the .NET runtime used). If an app is published framework-dependent (requiring a runtime installed on the system, like .NET 6 runtime), then similar to .NET Framework apps, it might not have obvious DLLs in the folder. However, many .NET Core apps still include some framework files (resources or smaller libraries). Also, administrators can inventory the installed runtimes on the system (e.g., via `dotnet --list-runtimes` or registry) and cross-correlate with the apps: if a machine has .NET 6 installed, likely some app on it needed it. The script could be extended to note what runtimes are installed on the PC (though Quynn’s did not need to since it looks at apps directly).

*   **Performance:** Scanning the file system on \~20,000 devices is heavy if done arbitrarily. But these scripts focus only on the program’s install directories, not the entire disk, which keeps the scope reasonable. SCCM’s similar “software inventory” feature warns that scanning entire drives for all EXEs can generate huge data and load, so targeting only known folders (like the ones in the registry uninstall list) is a smart approach. In testing, Quynn’s script scanning one machine with dozens of programs might run in a matter of seconds to a couple minutes. When scaling to thousands of machines, you will likely schedule the script to run during off hours or staggered. The good news is that tools like SCCM or Tanium can handle this fan-out efficiently (more on that next).

*   **False Positives/Negatives:** The method of using file version info works well for official Microsoft assemblies. But what if an app uses an embedded mono or a third-party .NET runtime? Unlikely in enterprise, but worth noting the script assumes Microsoft .NET. Also, if a .NET assembly in an app folder isn’t actually *required* for the program to run (perhaps a leftover or optional plugin), the script might still flag it. This typically isn’t a big issue – it’s safer to assume it might need it.

*   **Visual C++ vs .NET:** Quynn’s script tackles both, since old VC++ redistributables are another common legacy component. If you only care about .NET, you can ignore or remove the VisualCpp part. But if you’re delivering a comprehensive “runtime dependency” report, it’s a bonus that the script can also show which apps need, say, the 2010 VC++ runtime (by seeing msvcr100.dll in their folder), etc. The output marks those separately so you can differentiate.

*   **No “official” Microsoft script:** It’s worth noting that, as of now, Microsoft hasn’t published a ready-made script for this. The closest “official” guidance was the suggestion to manually use tools like dotPeek if needed. So the community solutions are the go-to. The script by Quynn Bell is public and can be used as-is or modified; other admins have likely written similar internal scripts. Always review and test scripts from the internet in a lab first, of course.


## **Deploying Across an Enterprise**

Running a script on one computer is easy; running it on 20,000 and consolidating the results is the real challenge. Fortunately, enterprises have management tools to do exactly that. Here are common methods to deploy these PowerShell scripts broadly and gather the data:

*   **Microsoft SCCM (Configuration Manager):** If you have SCCM (now part of Endpoint Manager), you can create a Deployment that runs the PowerShell script on all managed machines. For example, you might create a “Configuration Baseline” with a PowerShell script detection method, or use the **Run Scripts** feature to execute it on a collection. One approach is to have the script output the CSV to a known location (like `C:\ProgramDependencies.csv` as Quynn did) on each client, and then use SCCM’s hardware inventory to collect that file. SCCM’s hardware inventory can be extended to pick up custom files – you define a file collection rule for `C:\ProgramDependencies.csv`. Then when the clients run their next inventory cycle, they will attach that CSV file’s content back to the site server, where you can query it. Alternatively, the script could be altered to directly output results to the console, and the Run Scripts feature will capture each machine’s output (which you could then compile, albeit that may be a bit manual). SCCM is very scalable and can schedule this during maintenance windows. Many SCCM admins have used similar techniques for inventory data that isn’t available out-of-the-box.

*   **Microsoft Intune (Endpoint Manager):** If some PCs are only Intune-managed (no SCCM agent), you can use Intune’s **Proactive Remediations** (part of Endpoint Analytics) or a simple **PowerShell script deployment**. With proactive remediations, you have a detection script (which could run the .NET scan) and a remediation script (perhaps blank or used to upload data). Intune can record the output of the detection script, but it has a size limit (\~2048 characters). Outputting an entire list of apps might exceed that. A better strategy is to have the script send its output somewhere – for example, write to a log file that is configured to upload to an Azure Log Analytics workspace. If you have Azure Monitor agents, you could leverage those to collect the CSVs. In a pinch, the script could even email the results or post to an API, but that’s more complex. If Intune is used in co-management with SCCM, you might just run it via SCCM for all Windows devices. Intune can also run scripts on a schedule (daily/weekly) if you want to keep inventory updated.

*   **Tanium or Similar Endpoint Management Tools:** Many large orgs use tools like **Tanium** which can execute scripts and gather results in near-real-time. With Tanium, you could deploy the PowerShell script across all endpoints within minutes. Tanium’s distributed query would retrieve the content of each machine’s CSV or script output centrally without you having to manually aggregate. For example, Tanium’s “Ask a Question” could be like: *“Run PowerShell code X and return the CSV content”*. This is very efficient, especially if you already have Tanium agents. Other RMM (remote monitoring and management) tools can do similarly – Quynn mentioned their RMM agent could utilize PowerShell, which is why PS was a suitable choice.

*   **Group Policy / Startup Script:** In environments without fancy tools, one could even use a Group Policy Startup Script (or Scheduled Task via GPO) to run the PowerShell script at boot and write the CSV to a network share. Each machine could drop a file named after itself (e.g., `Hostname_ProgramDependencies.csv`) on a share that all machines can write to. This requires proper permissions and storage, but it’s a low-tech solution. You’d then have a folder full of CSVs from which to compile the master list. This approach might be prone to missing some machines or duplicates, but it can work in smaller setups or in a pinch.

*   **Microsoft Defender for Endpoint (MDE) Integration:** While not executing the script, it’s worth noting that since Defender’s Threat & Vulnerability Management already inventories software, you could use it to validate your results. Some orgs choose to export the software inventory from MDE (which lists all software but not their .NET link) and then cross-reference with the script’s output. MDE won’t tell you the .NET version usage, but it ensures you didn’t miss an app. (As an aside: if you have MDE, it may catch even apps not in Add/Remove, as noted earlier.)

Once you have collected the data from all devices, you’ll want to aggregate it. If it’s in a database like SCCM’s, you can write a SQL query or use Power BI to analyze it. If it’s in a bunch of CSV files, you can import them into Excel or a database. The end result is you can answer questions like: “How many apps in our environment require .NET 4.6.2? Which are they and on which machines?” This is incredibly useful for planning remediation. For example, if .NET 4.6.1 is out of support, you can identify exactly which applications (and where) are preventing its removal.

## **Comparing Script-Based Approaches**

To summarize the different techniques a script might use, here’s a comparison:

| **Approach & Example**                                                                     | **Methodology**                                                                                                                                                                                                                                       | **Pros**                                                                                                                                                                                                                                                                                                    | **Cons/Limitations**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| ------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **File Scan for .NET Assemblies**<br>(*e.g.*, Quynn Bell’s script)  | Enumerate installed apps, then scan each app’s install directory for known .NET assembly files (like `mscorlib.dll`, `System*.dll`). Use file version info of those DLLs to determine the .NET version.                         | – Leverages actual files shipped with the app, which directly reveal needed runtime version.<br>– Straightforward to implement with PowerShell’s Get-ChildItem and FileVersionInfo.<br>– Can also be extended to other dependencies (VC++, etc.) in one go.                           | – May **miss apps that don’t ship any .NET assemblies** (relying on global runtime). Those apps won’t have `mscorlib.dll` in their folder, for example.<br>– Requires that the DLL’s version maps to a runtime (generally true for Microsoft DLLs).<br>– Scanning lots of files, so some performance impact (though limited to program folders).                                                                                                                                                                |
| **Manifest/Config Parsing**<br>(*e.g.*, search `.exe.manifest` for .NET entry) | For each app, check if a manifest or config file exists that declares a dependency on .NET. Look for strings like `Microsoft.NETFramework` or `supportedRuntime` with a version in those files.                               | – Catches apps that explicitly declare required .NET in manifests (common for some ClickOnce or Windows apps).<br>– Easy to implement by reading text files, minimal overhead.                                                                                                                              | – Not all apps have manifests. Many .NET apps don’t have a separate manifest file at all, or the manifest might not mention .NET even if the app needs it.<br>– Might only indicate that .NET is needed, but not clearly which version (could potentially parse the version if present).                                                                                                                                                                                                                        |
| **Binary Metadata via Reflection**<br>(*Hypothetical PowerShell reflection script*)        | Attempt to load/analyze each EXE/DLL in the app’s folder using .NET reflection to see if it’s a managed assembly and get its metadata (like referenced assemblies or `TargetFrameworkAttribute`).                                                     | – Can directly identify if an EXE is a .NET assembly and what it targets (for example, reading the assembly’s attributes can give “.NETCoreApp,Version=v3.1” etc.).<br>– Doesn’t rely on the app including system DLLs, since the EXE itself is inspected. As long as the app is managed, this can find it. | – More complex to script: need to handle exceptions for native binaries (which will throw when trying to load).<br>– PowerShell 5 can only load .NET Framework assemblies (due to running on .NET Framework), so inspecting a .NET Core EXE might require PowerShell 7 or an external library like Mono.Cecil.<br>– Not commonly found as a ready script; you might have to write this logic yourself.                                                                                                          |
| **String Search in EXE**<br>(*e.g.*, Mark Keogan’s plan)            | Read the binary content of the application’s executable (and possibly DLLs) and search for known framework moniker strings like `"NETFramework,Version=v"` or `"NETCoreApp,Version=v"` followed by numbers. Extract the version number from the text. | – Will detect the target framework for most managed executables because the string is usually embedded in them.<br>– Doesn’t require loading the assembly or any special APIs — a simple byte scan.                                                                                             | – Could generate false positives or weird results if a string coincidentally appears in a non-related context (low chance, but possible).<br>– Reading large binaries entirely to memory to search might be slow; better to do a streamed search. Still, scanning a few hundred MB of executables per machine is doable, just not as elegant.<br>– Needs separate logic to map that framework version string to, say, a simpler label (e.g., “v4.7.2” -> .NET 4.7.2). Usually the string is clear enough as is. |

As you can see, each method has trade-offs. In practice, the **file scan method (first row)** combined with a bit of the **string search method** covers most bases and has been implemented by others successfully. The manifest method is supplemental. The reflection method, while robust, hasn’t been widely packaged in examples, likely because the file version approach solved the need without the extra complexity.

## **Example Output and Data Usage**

The output from these scripts is typically a list of applications with an associated .NET version. Quynn’s script, for example, produces a CSV with columns: Program, Version, Dependency, DependencyType, DependencyVersion. If you consolidate the results from all machines, you might end up with a table of (Machine, Program, .NET Version). This can be pivoted or analyzed to answer questions like:

*   “Which programs in our environment require .NET 4.6.0 or 4.6.1 (which are out of support)?”
*   “Are there any machines that have .NET 3.5 installed but no programs actually needing it (so we can potentially remove .NET 3.5 on those)?”
*   “What is the highest .NET version each app can work with? (If an app lists a dependency on 4.7, it will work on 4.8 as well, so maybe we just ensure 4.8 everywhere.)”

In our case, since you specifically want the breakdown by device, application, and .NET dependency version, the final dataset will look like a large three-level list. You can create a report per device, or per application:

*   **Per Device Report:** List each device and under it list all the software and what .NET each requires. This is useful to see, for example, on machine “OfficePC-99” we might see “App A – .NET 4.8, App B – .NET 6.0, App C – no .NET, etc.”
*   **Per Application Report:** List each application name (across the enterprise) and which .NET it needs, and possibly how many devices have it. For instance, “App XYZ – requires .NET 5.0 – installed on 150 computers”. This view helps target which apps are causing legacy .NET to stick around.

The script-provided data can feed either view. It might require some joining with your inventory of which devices have which software (but the script essentially provides that link itself if run on each machine).

The structured output (CSV/JSON) means you can programmatically combine the results. If using CSVs, you could use another PowerShell script to merge all CSVs into one big CSV. If using JSON and say uploading to a server, you could aggregate via a database.

## **Recommendations and Best Practices**

*   **Use the Community Script as a Starting Point:** The PowerShell script by Quynn Bell is a proven solution for this task. Even if you need to tweak it, it covers the bases and is already written and tested. You can find it on Quynn’s blog (May 23, 2024 post). It would be wise to test it on a handful of machines first to verify it catches the apps/versions you expect. Check the CSV output and see if it makes sense (e.g., if you know a certain app requires .NET 3.5, does the script find a dependency pointing to v2.0.50727 in that app’s folder?).

*   **Consider Augmenting for Edge Cases:** If you know some applications in your environment are .NET apps but the script isn’t reporting them (for example, some internally developed tool that completely relies on installed .NET and has no common DLLs in its folder), consider augmenting the script. You could add a routine that if DependencyType “DotNet” was not found for a program, then scan its main EXE for the string as a double-check. This hybrid approach would cover nearly 100% of cases. The performance hit of scanning, say, 50 EXEs on a machine for a text string is small.

*   **Structured Output Choice:** CSV is generally easiest and human-readable. JSON could be used if you intend to import into a NoSQL db or process with scripts. One advantage of JSON might be if you wanted to include more complex data (like an array of dependencies per app in one JSON document). But since CSV is already proven in this scenario, sticking with CSV is fine. It’s trivial to convert the objects to JSON in PowerShell if needed (`$dependencyInfo | ConvertTo-Json`).

*   **Integration with Inventory/CMDB:** Once you have the data, integrate it with your existing inventory or CMDB (Configuration Management Database). For instance, you might have a CMDB entry for each application; you can update it with “.NET version required”. Or at least store the CSV centrally for future reference. This exercise not only helps the immediate need (EOL software removal) but leaves you with a useful dataset for future audits.

*   **Privacy and Security:** The script is reading file paths and names of installed programs. This is generally fine in an enterprise, but be mindful if any machines might have unusual software or if the list of installed software is considered sensitive in your org. Also, running scripts via SCCM/Intune means you need appropriate permissions – typically an admin privilege, which those tools have by design on the client. The script itself is read-only (just scanning), so it’s low risk. Still, ensure the script comes from a trusted source (review the code; it should not be doing anything other than reading registry and files).

*   **Use the Data for Action:** After getting the inventory, the goal is to act on it – e.g., uninstall certain .NET versions from machines where they’re not needed, or target specific legacy apps for upgrade or retirement because they require an old framework. The report should highlight those clearly. For example, if only one app in the whole company requires .NET 4.5.2, and it’s on 10 PCs, that gives a very actionable item (either upgrade that app or isolate those PCs).

In conclusion, **PowerShell-based scanning is the recommended approach** to achieve a breakdown of devices, applications, and their .NET dependency versions. It’s a practical, scriptable solution born from community expertise, and it scales well when combined with enterprise management tools. By using these scripts, you’ll get a comprehensive inventory that was previously not attainable, enabling informed decisions in your software assessment project.
